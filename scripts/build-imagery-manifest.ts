import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ImageManifest {
  [key: string]: {
    src1200?: string;
    src2400?: string;
    blur?: string;
    fallback?: string;
  };
}

// Supported image extensions
const IMAGE_EXTENSIONS = ['.webp', '.jpg', '.jpeg', '.png'];

// Extract base name from filename, removing size suffixes
function extractBaseName(filename: string): string {
  // Remove extension
  const nameWithoutExt = path.parse(filename).name;
  
  // Remove common size suffixes
  const sizeSuffixes = ['-1200', '-2400', '-blur', '-thumb', '-small', '-large'];
  let baseName = nameWithoutExt;
  
  for (const suffix of sizeSuffixes) {
    if (baseName.endsWith(suffix)) {
      baseName = baseName.slice(0, -suffix.length);
      break;
    }
  }
  
  return baseName;
}

// Check if a file exists
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

// Scan directory for images
async function scanDirectory(dirPath: string, baseUrl: string): Promise<Map<string, string[]>> {
  const imageMap = new Map<string, string[]>();
  
  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    
    for (const entry of entries) {
      if (entry.isFile()) {
        const ext = path.extname(entry.name).toLowerCase();
        if (IMAGE_EXTENSIONS.includes(ext)) {
          const baseName = extractBaseName(entry.name);
          const fullPath = path.join(dirPath, entry.name);
          const url = `${baseUrl}/${entry.name}`;
          
          if (!imageMap.has(baseName)) {
            imageMap.set(baseName, []);
          }
          imageMap.get(baseName)!.push(url);
        }
      } else if (entry.isDirectory()) {
        // Recursively scan subdirectories
        const subDirPath = path.join(dirPath, entry.name);
        const subDirUrl = `${baseUrl}/${entry.name}`;
        const subMap = await scanDirectory(subDirPath, subDirUrl);
        
        for (const [key, urls] of subMap) {
          if (!imageMap.has(key)) {
            imageMap.set(key, []);
          }
          imageMap.get(key)!.push(...urls);
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not scan directory ${dirPath}:`, error);
  }
  
  return imageMap;
}

// Categorize images by type
function categorizeImages(urls: string[]): { src1200?: string; src2400?: string; blur?: string; fallback?: string } {
  const result: { src1200?: string; src2400?: string; blur?: string; fallback?: string } = {};
  
  for (const url of urls) {
    const filename = path.basename(url);
    const nameWithoutExt = path.parse(filename).name;
    
    if (nameWithoutExt.endsWith('-1200')) {
      result.src1200 = url;
    } else if (nameWithoutExt.endsWith('-2400')) {
      result.src2400 = url;
    } else if (nameWithoutExt.endsWith('-blur')) {
      result.blur = url;
    } else {
      // This is a fallback image (original)
      result.fallback = url;
    }
  }
  
  return result;
}

// Generate the manifest
async function generateManifest(): Promise<void> {
  console.log('üñºÔ∏è  Building imagery manifest...');
  
  const projectRoot = path.join(__dirname, '..');
  const publicDir = path.join(projectRoot, 'public');
  const optimizedDir = path.join(projectRoot, 'public', 'optimized');
  const outputFile = path.join(projectRoot, 'src', 'lib', 'imagery.ts');
  
  // Ensure output directory exists
  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  
  // Scan both directories
  console.log('üìÅ Scanning /public...');
  const publicImages = await scanDirectory(publicDir, '');
  
  console.log('üìÅ Scanning /public/optimized...');
  const optimizedImages = await scanDirectory(optimizedDir, '/optimized');
  
  // Merge the results
  const allImages = new Map<string, string[]>();
  
  // Add public images
  for (const [key, urls] of publicImages) {
    if (!allImages.has(key)) {
      allImages.set(key, []);
    }
    allImages.get(key)!.push(...urls);
  }
  
  // Add optimized images
  for (const [key, urls] of optimizedImages) {
    if (!allImages.has(key)) {
      allImages.set(key, []);
    }
    allImages.get(key)!.push(...urls);
  }
  
  // Build the manifest
  const manifest: ImageManifest = {};
  
  for (const [key, urls] of allImages) {
    manifest[key] = categorizeImages(urls);
  }
  
  // Generate TypeScript file
  const tsContent = `// Auto-generated imagery manifest
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually - run 'npm run imagery:manifest' to regenerate

export interface ImageManifest {
  [key: string]: {
    src1200?: string;
    src2400?: string;
    blur?: string;
    fallback?: string;
  };
}

export const IMAGERY: ImageManifest = ${JSON.stringify(manifest, null, 2)};

// Helper function to get image info
export function getImageInfo(name: string): ImageManifest[string] | null {
  return IMAGERY[name] || null;
}

// Helper function to check if image exists
export function hasImage(name: string): boolean {
  return name in IMAGERY;
}

// Helper function to get all available image names
export function getAllImageNames(): string[] {
  return Object.keys(IMAGERY);
}
`;
  
  // Write the file
  await fs.writeFile(outputFile, tsContent, 'utf-8');
  
  console.log(`‚úÖ Manifest generated: ${outputFile}`);
  console.log(`üìä Found ${Object.keys(manifest).length} unique images`);
  
  // Show some stats
  let optimizedCount = 0;
  let fallbackCount = 0;
  
  for (const [key, info] of Object.entries(manifest)) {
    if (info.src1200) optimizedCount++;
    if (info.fallback) fallbackCount++;
  }
  
  console.log(`üéØ Optimized images: ${optimizedCount}`);
  console.log(`üîÑ Fallback images: ${fallbackCount}`);
  
  // Show some examples
  const examples = Object.entries(manifest).slice(0, 3);
  if (examples.length > 0) {
    console.log('\nüìã Examples:');
    for (const [key, info] of examples) {
      console.log(`  ${key}:`, info);
    }
  }
}

// Run the script
generateManifest().catch(console.error);
