#!/usr/bin/env node
import sharp from 'sharp';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INPUT_DIR = '/home/michael/Public/images';
const OUTPUT_DIR = './public/imagery/processed';
const WIDTHS = [1200, 2400];

// Master Content Lock Section 9 - Required image mappings
const REQUIRED_IMAGES = {
  'ai_construction_bridge_banner.png': 'home_hero_main',
  'ai_technology.jpeg': 'home_hero_overlay', 
  'Hard_Hat_ digital_paperwork.jpeg': 'home_problem_main',
  'data_sovereignty_badge.png': 'home_solution_badge',
  'michael_howardbio.jpeg': 'fusion_michael',
  'AI_DNA.png': 'fusion_ai_ethics',
  'HISL_Logo.jpeg': 'footer_logo_hisl',
  'integai_logo.png': 'footer_logo_integai',
  'reach_for_the_stars.png': 'poem_backdrop',
  'raven_muninn.png': 'globe_raven_muninn',
  'raven_huginn.png': 'globe_raven_huginn',
  'earth_globe_realistic.png': 'globe_base',
  'inspiring.jpg': 'footer_accent',
  'creation_AI.png': 'news_motif',
  'compliance_shield_premium.png': 'home_solution_security'
};

async function processImages() {
  console.log('üîç Sharp Image Processing Pipeline');
  console.log('=====================================');
  
  // Ensure output directory exists
  await fs.mkdir(OUTPUT_DIR, { recursive: true });
  
  const manifest = {};
  let processedCount = 0;
  let skippedCount = 0;
  
  try {
    // Scan input directory
    const files = await fs.readdir(INPUT_DIR, { recursive: true });
    console.log(`üìÅ Found ${files.length} files in ${INPUT_DIR}`);
    
    for (const file of files) {
      if (!/\.(jpg|jpeg|png|webp)$/i.test(file)) {
        continue;
      }
      
      const inputPath = path.join(INPUT_DIR, file);
      const baseName = path.parse(file).name;
      const extension = path.parse(file).ext.toLowerCase();
      
      // Map to canonical imageId from Master Content Lock
      const imageId = REQUIRED_IMAGES[file] || baseName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
      
      try {
        console.log(`üñºÔ∏è  Processing: ${file} ‚Üí ${imageId}`);
        
        // Generate WebP + sizes + placeholder
        const imageData = await processImage(inputPath, imageId, baseName);
        manifest[imageId] = imageData;
        processedCount++;
        
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Failed to process ${file}:`, error.message);
        skippedCount++;
      }
    }
    
    // Write typed manifest
    await writeManifest(manifest);
    
    console.log('\n‚úÖ Sharp Processing Complete!');
    console.log(`üìä Processed: ${processedCount} images`);
    console.log(`‚ö†Ô∏è  Skipped: ${skippedCount} images`);
    console.log(`üìÑ Manifest: src/lib/imagery.ts`);
    console.log(`üìÅ Output: ${OUTPUT_DIR}`);
    
  } catch (error) {
    console.error('‚ùå Sharp processing failed:', error);
    process.exit(1);
  }
}

async function processImage(inputPath, imageId, baseName) {
  const metadata = await sharp(inputPath).metadata();
  
  if (!metadata.width || !metadata.height) {
    throw new Error('Invalid image metadata');
  }
  
  const aspectRatio = metadata.width / metadata.height;
  const results = {};
  
  // Process each width
  for (const width of WIDTHS) {
    const height = Math.round(width / aspectRatio);
    const outputPath = path.join(OUTPUT_DIR, `${baseName}-${width}.webp`);
    
    await sharp(inputPath)
      .resize(width, height, { fit: 'cover', position: 'center' })
      .webp({ quality: 85 })
      .toFile(outputPath);
    
    results[`src${width === 2400 ? '2x' : ''}`] = `/imagery/processed/${path.basename(outputPath)}`;
  }
  
  // Generate LQIP placeholder
  const placeholder = await sharp(inputPath)
    .resize(20, Math.round(20 / aspectRatio))
    .blur(1)
    .webp({ quality: 20 })
    .toBuffer();
  
  const placeholderBase64 = `data:image/webp;base64,${placeholder.toString('base64')}`;
  
  return {
    src: results.src,
    src2x: results.src2x,
    placeholder: placeholderBase64,
    width: metadata.width,
    height: metadata.height,
    aspectRatio: aspectRatio
  };
}

async function writeManifest(manifest) {
  const manifestContent = `/**
 * Imagery Manifest - Generated by Sharp Pipeline
 * Source: Master Content Lock Section 9
 * Generated: ${new Date().toISOString()}
 * 
 * This file is auto-generated. Do not edit manually.
 * Run: npm run imagery:process
 */

export const IMAGES = ${JSON.stringify(manifest, null, 2)} as const;

export type ImageId = keyof typeof IMAGES;

// Validation helpers
export function hasImage(imageId: string): imageId is ImageId {
  return imageId in IMAGES;
}

export function getImageInfo(imageId: ImageId) {
  return IMAGES[imageId];
}
`;

  await fs.writeFile('./src/lib/imagery.ts', manifestContent, 'utf8');
  console.log('üìÑ Generated: src/lib/imagery.ts');
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  processImages().catch(console.error);
}

export { processImages };